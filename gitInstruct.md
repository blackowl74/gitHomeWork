# Инструкция по использованию системы контроля версий - GIT

> GIT - это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Например, для картинок - полезно для дизайнеров.

![файловая система](img/file-system-git.webp)

## Терминология 

Самое время пополнить ваш Git-словарик, прежде чем создадим первый Pull Request.

*       Репозиторий (repository) — директория проекта, который отслеживается Git. В директории хранится проект, история изменений и мета-информация проекта (в скрытой директории .git).

*       Индекс — хранилка, где лежат имена файлов и их изменения, которые должны быть в следующем коммите. По факту индекс — просто файл. В индекс файлы сами не попадают, их нужно явно добавлять при помощи git add.

*       Коммит (commit) — это фиксация изменений в истории проекта (изменения, которые внесены в индекс). Коммит хранит изменённые файлы, имя автора коммита и время, в которое был сделан коммит. Кроме того, каждый коммит имеет уникальный идентификатор, который позволяет в любое время к нему откатиться. Можете считать коммит этакой точкой сохранения.

*       Ветка (branch) — последовательность коммитов. По сути — ссылка на последний коммит в этой ветке. Ветки не зависят друг от друга — можно вносить изменения в одну, и они не повлияют на другую (если вы явно этого не попросите). Работать вы начинаете в одной ветке — main, увидите чуть позже.

*       Форк (Fork) — собственное ответвление (fork) какого-то проекта. Это означает, что GitHub создаст вашу собственную копию проекта, данная копия будет находиться в вашем пространстве имён, и вы сможете легко делать изменения путём отправки (push) изменений.

*       Пул-реквест — pull request — предложение изменения кода в чужом репозитории. Допустим, вы забрали к себе чужой репозиторий, поработали с ним и теперь хотите, чтобы ваши изменения попали в оригинальный репозиторий — тогда вы создаёте создаёте PR с просьбой добавить ваши изменения в репозиторий.

## Установка и первоначальная настройка GIT

### Установка

Установить git на свою машину очень просто:

* Linux — нужно просто открыть терминал и установить приложение при помощи пакетного менеджера вашего дистрибутива. Для Ubuntu команда будет выглядеть следующим образом:

        sudo apt-get install git

* Windows — мы рекомендуем git for windows, так как он содержит и клиент с графическим интерфейсом, и эмулятор bash.
* OS X — проще всего воспользоваться homebrew. После его установки запустите в терминале:

        brew install git

> Если вы новичок, клиент с графическим интерфейсом(например GitHub Desktop и Sourcetree) будет полезен, но, тем не менее, знать команды очень важно.

### Настройка 

> Есть довольно много опций, с которыми можно играть, но мы настроим самые важные: наше `имя пользователя` и `адрес электронной почты`. Откройте терминал и запустите команды:

        git config --global user.name "My Name"
        git config --global user.email myEmail@example.com

**Теперь каждое наше действие будет отмечено именем и почтой. Таким образом, пользователи всегда будут в курсе, кто отвечает за какие изменения — это вносит порядок.**

Git хранит весь пакет конфигураций в файле `.gitconfig`, находящемся в вашем локальном каталоге. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам, необходимо добавить флаг `–global`. Если вы этого не сделаете, они будут распространяться только на текущий репозиторий.
Для того, чтобы посмотреть все настройки системы, используйте команду:

        git config --list
Для удобства и легкости зрительного восприятия, некоторые группы команд в Гит можно выделить цветом, для этого нужно прописать в консоли:

        git config --global color.ui true
        git config --global color.status auto
        git config --global color.branch auto

Если вы не до конца настроили систему для работы, в начале своего пути - не беда. Git всегда подскажет разработчику, если тот запутался, например:

> **Команда `git --help` - выводит общую документацию по git
Если введем `git log --help` - он предоставит нам документацию по какой-то определенной команде (в данном случае это - log)**

*Если вы вдруг сделали опечатку - система подскажет вам нужную команду*

*После выполнения любой команды - отчитается о том, что вы натворили*

*Также Гит прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше*


## Основные команды

### Справочные команды

* git status - проверка состояния
* git log - просмотр истории коммитов с хэш-номерами каждого коммита
* git show hash-commit - просмотр всех изменений определённого коммита
* git diff - просмотр изменений и разницы между определёнными коммитами

#### Ярлыки состояния файлов

* U - (untracked) - файл не отслеживается
* A - (added) - файл добавлен и отслеживается
* M - (modified) - файл изменён

### Работа с файлами
* git init - инициализация репозитория
* git add "file-name" - добавление файла(ов) для отслеживания (имя файла указывается без кавычек)
* git reset "file-name" - убрать ненужный файл(ы), если вдруг добавили лишнего 
* git commit - создание "точки сохранения" нашего репозитория (есть несколько вариаций, но всегда необходимо указывать комментарий к коммиту)
    * -m "message" - позволяет написать сообщение вместе с командой, не открывая редактор (кавычки обязательны)
    * -a -m "message" - добавление файлов и комментария одновременно (позволяет пропустить команду git add)
    * -am "message" - сокращённая запись команды выше
    * -amend -m "new message" - позволяет заменить комментарий определённого коммита


> ***Коммиты хранят состояние файловой системы в определённый момент времени и указатели на предыдущие коммиты. Каждый коммит содержит уникальную контрольную сумму — идентификатор, который Git использует, чтобы ссылаться на коммит. Чтобы отслеживать историю, Git хранит указатель HEAD, который указывает на первый коммит (мы следуем по цепочке коммитов в обратном порядке, чтобы попасть к предыдущим коммитам).***

![commit history](img/commit-history.webp)

Мы можем ссылаться на коммит либо через его контрольную сумму, либо через его позицию относительно HEAD, например HEAD~4 ссылается на коммит, который находится 4 коммитами ранее HEAD.

### Работа с ветками

![branches](img/masterdev.png)

> Ветвление — это возможность работать над разными версиями проекта: вместо одного списка с упорядоченными коммитами история будет расходиться в определённых точках. Каждая ветвь содержит легковесный указатель HEAD на последний коммит, что позволяет без лишних затрат создать много веток. Ветка по умолчанию называется master, но лучше назвать её в соответствии с разрабатываемой в ней функциональностью.

![branching](img/branching1.webp)

#### Команды

* git checkout branch-name - перемещение между ветками
* git checkout hash-commit - переход к коммиту
* git branch - создание ветки
    * -d - модификатор позволяет удалить ветку
    * -D - позволяет принудительно удалить ветку
* git merge branch-name - слияние веток

#### Прятки и чистка

> Есть одна тонкость — при переключении веток Git требует, чтобы рабочее состояние было чистым, то есть все изменения в отслеживаемых файлах должны быть зафиксированы.

Однако порой у вас есть незавершённые изменения, которые нельзя фиксировать. В такой ситуации их можно сохранить и «спрятать» с помощью команды `git stash`. Чтобы вернуть изменения, используйте `git stash apply`.

#### Слияние 


***Ветку, в которую мы хотим слить изменения, будем называть основной, а ветку, из которой мы будем их сливать, — тематической.***

![merge](img/merge.jpg)

> Слиние включает в себя создание нового коммита, который основан на общем коммите-предке двух ветвей и указывает на оба HEAD в качестве предыдущих коммитов. Для слияния мы переходим на основную ветку и используем команду `git merge <тематическая ветка>`.

Если обе ветви меняют одну и ту же часть файла, то возникает конфликт слияния — ситуация, в которой Git не знает, какую версию файла сохранить, поэтому разрешать конфликт нужно собственноручно. Чтобы увидеть конфликтующие файлы, используйте `git status`.

![conflict](img/merge-conflict.svg)

#### Перемещение

> Вместо совмещения двух ветвей коммитом слияния, перемещение заново воспроизводит коммиты тематической ветки в виде набора новых коммитов базовой ветки, что выливается в более чистую историю коммитов.

![rebase](img/rebase.webp)

Для перемещения используется команда `git rebase <основная ветка> <тематическая ветка>`, которая воспроизводит изменения тематической ветки на основной; HEAD тематической ветки указывает на последний воспроизведённый коммит.


#### Перемещение vs. слияние

> **После слияния лог с историей может выглядеть довольно беспорядочно. С другой стороны, перемещение позволяет переписать историю в нормальной, последовательной форме. Но перемещение — не панацея от запутанных логов: перемещённые коммиты отличаются от оригинальных, хотя и имеют одного и того же автора, сообщение и изменения.**

*Например, пойдем по такому сценарию:* 

* В своей ветке вы создаёте несколько коммитов и сливаете их в мастер-ветку.
* Кто-то ещё решает поработать на основе ваших коммитов.
* Вы решаете переместить ваши коммиты и отправить их на сервер.
* Когда кто-то попытается слить свою работу на основе ваших изначальных коммитов, в итоге мы получим две параллельные ветки с одним автором, сообщениями и изменениями, но разными коммитами.

> ***Перемещайте изменения только на вашей приватной локальной ветке — не перемещайте коммиты, от которых зависит ещё кто-то.***

#### Откат коммитов — revert и reset
> *Похожие дебаты по поводу того, что лучше использовать, возникают, когда вы хотите откатить коммит. Команда `git revert <коммит>` **создаёт новый коммит, отменяющий изменения, но сохраняющий историю**, в то время как `git reset <коммит>` **перемещает указатель HEAD, предоставляя более чистую историю (словно бы этого коммита никогда и не было).** Важно отметить, что это также означает, что **вы больше не сможете вернуться обратно к этим изменениям**, например, если вы всё-таки решите, что отмена коммита была лишней. Чище — не значит лучше!*

## Работа с удалёнными репозиториями

> Мы можем хранить историю коммитов удалённых репозиториев, которую можно отслеживать и обновлять. `git remote -v` выводит список удалённых репозиториев, которые мы отслеживаем, и имена, которые мы им присвоили.

**При использовании команды `git clone <url репозитория>` мы не только загружаем себе копию репозитория, но и неявно отслеживаем удалённый сервер, который находится по указанному адресу и которому присваивается имя origin.**

### GitHub

> GitHub — крупнейший веб-сервис, который позволяет заниматься совместной разработкой с использованием Git и сохранять изменения на своих серверах. На самом деле функциональность GitHub намного больше, но сейчас нас интересует только совместная разработка и история изменений. Ещё есть Gitlab, Bitbucket и другие, но мы будем использовать GitHub как самый популярный в настоящее время.

### Команды

* git remote add <имя> <url> — добавляет удалённый репозиторий с заданным именем;
* git remote remove <имя> — удаляет удалённый репозиторий с заданным именем;
* git remote rename <старое имя> <новое имя> — переименовывает удалённый репозиторий;
* git remote set-url <имя> <url> — присваивает репозиторию с именем новый адрес;
* git remote show <имя> — показывает информацию о репозитории.

**Следующие команды работают с удалёнными ветками:**

* git fetch <имя> <ветка> — получает данные из ветки заданного репозитория, но не сливает изменения;
* git pull <имя> <ветка> — сливает данные из ветки заданного репозитория;
* git push <имя> <ветка> — отправляет изменения в ветку заданного репозитория. Если локальная ветка уже отслеживает удалённую, то можно использовать просто git push или git pull.


![pull&push](img/push-pull.jpg)

> ***Таким образом несколько людей могут запрашивать изменения с сервера, делать изменения в локальных копиях и затем отправлять их на удалённый сервер, что позволяет взаимодействовать друг с другом в пределах одного репозитория.***


### Как настроить совместную работу

1. Создать аккаунт на GitHub.com
2. Создать локальный репозиторий
3. “Подружить” ваш локальный и удалённый репозитории. (GitHub при создании нового репозитория подскажет, как это можно сделать)
4. Отправить (push) ваш локальный репозиторий в удалённый (на GitHub), при этом, возможно, 
вам нужно будет авторизоваться на удалённом репозитории
5. Провести изменения “с другого компьютера”
6. Выкачать (`pull`) актуальное состояние из удалённого репозитория

### Pull request

* команда для предложения изменений
* запрос на вливание изменений в репозиторий

> **В больших компаниях один ответственный за проект создает аккаунт. Другие пользователи дают
команду `pull request`. Предлагать изменения на GitHub нужно в отдельной ветке. Сначала
пользователь копирует репозиторий на свой компьютер, делает `fork` репозитория, затем
клонирует версию на своём ПК, создаёт ветку с предлагаемыми изменениями, отправляет
изменения командой push в свой аккаунт на GitHub и даёт команду `pull request`.**

#### Fork

> Cобственное ответвление (`fork`) какого-то проекта. Это означает, что GitHub создаст вашу собственную копию проекта, данная копия будет находиться в вашем пространстве имён, и вы сможете легко делать изменения путём отправки (`push`) изменений.

#### Как сделать pull request
* Делаем   (ответвление) репозитория `fork`
* Делаем `git clone`   версии репозитория СВОЕЙ
* Создаем новую ветку и в НЕЕ вносим свои изменения
* Фиксируем изменения (делаем коммиты)
* Отправляем свою версию в свой GitHub
* На сайте GitHub нажимаем кнопку `pull request`

